## 数组

​	数组可以存放多个**同一类型**的数据。是一种引用类型。

* 初始化

  * 动态初始化

    `数据类型[] 数组名 = new 数据类型 [size]; `或 `数据类型 数组名[] = new 数据类型 [size];`

    * 没有放数据时，不同数据类型的默认初始值为：
      * 整型：0
      * 浮点型：0.0
      * char：0
      * boolean：false
      * String：null

    * 声明数组 `int []a;` 或 `int a[];`

      声明之后a为null空值，尚未分配任何空间。

    * 创建数组 `a = new int[10];`

      为a分配空间。

      可以通过Array.length属性拿到数组长度。

  * 静态初始化

    `数据类型 数组名[] = {/*数组元素*/};`

    `int a[] = {1,2,3};`

* 数组的赋值机制

  数组赋值是按引用传递，附的值是**地址**。这种传值方式叫做**地址/引用拷贝**。

  在jvm的内存里

  * 基本数据类型保存在栈中

  * 数组等引用类型，其数据保存在堆里，在栈中存储的是堆里数据的地址。赋值时只会把堆的地址赋给新的变量。

    ![](D:\1学习\1编程\后端\韩顺平java\noteimages\引用传值.GIF)

* 数组扩容

  创建一个新数组，长度为原数组的length+1，再将原数组和新数据拷贝到新数组。

### 排序

## 面向对象

* 对象在内存中的存在形式

  在栈中存放指向堆的地址，堆中存放对象的数据，基本类型直接存储，引用类型存放在方法区的常量池中。

  ![](D:\1学习\1编程\后端\韩顺平java\noteimages\对象在内存中的存储形式.JPG)

* 成员变量=属性property=field字段

* 对象的访问修饰符
  * public
  * protected
  * 默认
  * private

* 属性如果不赋值，有默认值，同数组

* Java创建对象的流程
  1. 先加载类的信息，多次创建对象，类的信息只会加载一次
  
  2. 在堆中分配空间，进行默认初始化
  
     * 先进行默认初始化
  
     * 再进行显示初始化（即在类的属性中指定的值）比如
  
       ```java
       class Person {
           int age = 90; // 显示初始化
       }
       ```
  
     * 最后进行构造器的初始化
  
  3. 把堆中的地址赋给栈中的变量
  
* 方法的调用机制
  * 当程序执行到方法时，会开辟一个独立的栈空间
  * 当方法执行完毕或执行到return语句，就会返回

* 成员方法之间的调用

  * 会受到修饰符的限制
  * 同一个类之间的方法：直接调用
  * 不同类直接的方法：先创建类，然后`对象名.方法名`


* 方法传参，对于基本数据类型，形参变化不影响实参的底层原理：

  方法的实参传给形参在一个独立的栈中，对于基本数据类型，独立的栈里的形参变化不会影响主方法栈中的实参。

  而对于引用类型，传递的值是地址，因此对形参的改变会影响实参。

### 递归

* 如果在递归的时候传递引用类型，则只传递地址，会共享数据

#### 迷宫

* 使用递归回溯的思想
* 思考1：递归层数=>步数，循环/if-else=>走的路线方案（方向）
* 思考2：更多的方向=>更多的if-else判断
* 思考3：没有出现3=>没有死路，第一条路就出结果了
* 思考4：递归的执行顺序是，先进入的函数后返回。因此是一条路走到死，才会走下一条，属于深度优先搜索。
* 回溯：当一条路返回false之后，会回溯到上一个点，走另一条分支。

### 重载overload

* 在同一个类中，多个同名方法存在，但形参列表不一致

* 返回类型和变量名不同，不会构成重载

  ```java
  public int calculate(int n1,int n2) {}
  public void calculate(int n1,int n2) {} // 方法的定义重复，不构成重载
  ```

### 可变参数

* 将同一个类中，多个同名、同功能、但参数个数不同的方法封装成一个方法。

  ```java
  // 可以传入0个或多个int型参数
  public int sum(int... nums) {
      // nums可以当做一个int型数组使用
  }
  ```

* 一个方法只能有一个可变参数，且必须放在最后

### 作用域

* 全局变量（类的属性）可以不赋值，直接使用，有默认值
* 方法中的局部变量没有默认值，必须先赋值再使用

* 局部变量和全局变量可以重名，会覆盖全局变量。
* 同一作用域的变量不能重名
* 只有全局变量可以加修饰符

### 构造器Constructor

* 用于对新对象的初始化（不是创建对象，调用构造器时对象已经存在），构造器的方法名需要和类名一致

* 构造器**没有返回值**，也没有返回类型（不要写void）

* 构造器的调用，在new对象时，由系统完成

* 构造器可以传入不同的形参，进行重载

* 默认构造器：

  * 形式：

    ```java
    类名() {} // 没有参数，也没有内容
    ```

  * 一旦定义了自己的构造器，默认构造器会被覆盖，如果想使用需要手动定义

### this关键字

* this指向当前对象

* 可用于区分当前类的属性和局部变量

* 如果出现了构造器的重载，在构造器中，可以通过`this(参数列表)`的方式访问另一个构造器

  必须放在第一条语句。

  ```java
  public T() {
      this('jack',100);
  }
  
  public T(String name, int age) {}
  ```

### 访问修饰符

用于控制方法和属性的访问权限。

其中默认修饰符和public可以修饰类。

* public：对外公开（同类、同包、子类、不同包均可访问）
* protected：对子类和同一个包中公开
* 默认：无修饰符号，向同一个包中的类公开
* private：只有类本身可以访问

### 封装

​	encapsulation

* 封装的实现
  * 将属性用private进行私有化
  * 提供公共的set/get方法，在对属性进行赋值/读取，赋值/读取之前进行逻辑判断
  * 在构造器中也应该使用set/get方法，以便对数据进行验证

### 继承

​	当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义相同的属性的和方法，所有子类继承。

* 父类（超类、基类）：写共有的属性和方法
* 子类（派生类）：写特有的属性和方法



* 语法：

  ```java
  class 子类 extends 父类 {}
  ```

  子类就会拥有父类的属性和方法

* 子类必须调用父类的构造器，完成父类的初始化。

  先调用父类的无参构造器，再调用子类自己的构造器。

  如果父类没有无参构造器，则必须在子类用super去指定用父类的哪个构造器对父类进行初始化。

  如果在查找过程中，找到了父类的方法不能访问（比如private），则直接报错，不会再查找上一层。
  
  ```java
  class Father {
      String name;
      int age;
      public Father(String name, int age) {
          this.name = name;
          this.age = age;
      }
  }
  
  class Son extends Father {
      public Son() {
          super("没有名字",10); // 指定父类的带参数构造器
  }
  }
  ```



* 在java中，Object是所有类的父类

* 一个子类只能继承一个父类

* 继承的内存本质：

  继承的本质是定义了查找关系：

  * 在访问一个属性是，先查找子类是否有该属性且是否可以访问。如果有就返回信息。
  * 如果子类没有，就逐级查找父类，直到Object。
  * 如果查找过程中找到了，但是不能访问（比如为private），则会报错，不会继续向上查找。

### super关键字

super关键字是父类的引用，用于访问父类的属性、方法、构造器（不能访问没有权限的属性/方法，如私有private属性/方法）

* 使用`super()`访问父类构造器，只能放在构造器的第一句。

* 当子类成员名和父类一致时，需要通过super关键字访问父类的成员

* super和this都必须放在第一行，因此不能共存在一个构造器中（即有this也不会调用默认的super了）

  在构造器中，如果第一行没有super或this，才会有默认的super()

* 访问方法/属性时，先找本类，如果没有则会依次向上查找父类，直到Object。

  因此在父类方法与子类重名时，调用父类方法必须使用super关键字。

### 方法的重写override

​	方法的override重写/覆盖，是指子类有一个方法，与父（祖先）类方法的名称、返回类型、参数完全一样，子类的该方法就会覆盖父类的方法。

* 子类方法的返回类型需要跟父类一样，或者是父类返回类型的子类
* 子类方法不能缩小父类方法的访问权限

* 与重载进行对比

| 名称         | 范围               | 方法名   | 形参列表                       | 返回类型                                   | 访问范围                           |
| ------------ | ------------------ | -------- | ------------------------------ | ------------------------------------------ | ---------------------------------- |
| 重载overload | 同类               | 必须一致 | 需要有不同（类型、个数、顺序） | 无要求                                     | 无要求                             |
| 重写override | 父（祖先）类与子类 | 必须一致 | 必须一致                       | 子类的返回类型需要和父类一致、或是其子类型 | 子类方法不能缩小父类方法的访问范围 |

### 多态polymorphic

​	方法或对象具有多种形态。

* 多态是建立在封装和继承之上的，即首先两个类存在继承关系

* 重载和重写就体现了方法的多态。

* 对象的多态：

  对象的多态是多态的核心。

  几个关键点：

  1. 一个对象的编译类型和运行类型可以不一致
  2. 编译类型在定义对象时确定，不可改变
  3. 运行类型可以变化
  4.  声明对象时，`=`左边为编译类型，`=`右边为运行类型

```java
Animal animal = new Dog(); // 可以让一个父类的引用指向一个子类的对象。编译类型是Animal，运行类型是Dog。
animal = new Cat(); // 此时运行类型是Cat，编译类型仍然是Animal
```

#### 向上转型

* 本质：父类的引用指向子类的对象

  ```java
  Object obj = new Cat();
  ```

* 此时可以按访问权限调用父类（编译类型）中的所有成员，但不能调用子类（运行类型）的特有成员。

  最终运行效果按照子类（运行类型）的具体实现。

  即：只能调用父类本身的方法，或是子类重写父类的方法。

  * 在编译阶段，能够调用哪些成员，由编译类型决定
  * 方法的具体运行由运行类型决定

#### 向下转型

* 即将父类的引用强制类型转换为子类的引用

  ```java
  Animal animal = new Cat(); // 对象本身就是Cat类型
  Cat cat = (Cat)animal;// 只能转换成Cat类型，不可以转换成其他类
  ```

* 只能转换父类的引用，无法改变对象。

* 向下转型后即可调用子类的成员

* 属性直接由编译类型决定。不会类似方法的子类对父类重写的设定。

  ```java
  // Animal的age是10，Cat的age是20
  Animal animal = new Cat();
  System.out.println(animal.age); // 10
  ```

#### instanceOf运算符

* `A instanceOf B`如果A与B**运行**类型一致或A是B的子类型，则返回true；否则返回false。

  ```java
  // Father是Son的父类
  Father father = new Son(); // father的编译类型是Father，运行类型是Son
  System.out.println(father instanceOf Son); // 输出为true，比较的是运行类型Son
  ```

#### 动态绑定机制

* 调用对象的方法时，方法会和对象的内存地址/运行类型绑定，即从运行类型开始查找方法

* 调用对象的属性时，没有动态绑定机制

  ```java
  public class DynamicBind {
      public static void main(String[] args) {
          A a = new B();
          System.out.println(a.sum()); // B getI 30
          System.out.println(a.sum1()); // 22
      }
  }
  
  class A {
      public int i = 12;
  
      public int sum() {
          return getI() + 10;
      }
  
      public int sum1() {
          return i + 10;
      }
  
      public int getI() {
          System.out.println("A getI");
          return i;
      }
  }
  
  class B extends A {
      public int i = 20;
  
      public int getI() {
          System.out.println("B getI");
          return i;
      }
  }
  
  ```

  * a的编译类型为A，运行类型为B，向上转型。
  * B中没有sum方法，`a.sum()`根据继承调用A中的sum方法。而A中的sum方法调用`getI`方法时，会调用**运行类型B的getI方法**。
  * 通过sum1或getI方法访问i属性时，由于属性不存在动态绑定机制，因此访问的都是各自类自身的i属性。

#### 多态数组

​	数组的定义类型时父类类型，里面保存的实际元素是子类类型。示例代码可以看`polayArr`文件。

* 多态数组在遍历时可以通过`instanceof`运算符判断运行类型，然后进行向下转型，从而调用子类的特有方法。

#### 向下转型和instanceof的简写

* 在需要使用instanceof进行类型判断后进行向下转型时，似乎可以进行简写。

  ```java
  if(persons[i] instanceof Student) {
      Student student = (Student)persons[i];
     	student.study();
  }
  
  // 简写后
  if(persons[i] instanceof Student student) {
      student.study();
  }
  ```


#### 多态参数

​	方法的形参定义为父类类型，实参允许传递子类类型。

## 包

本质上就是创建不同的文件夹来保存类文件。

* 包命名规范：公司名.项目名.模块名	都用小写字母
* java中的包：
  * java.lang.* 基本包，默认引入，无需再引入
  * java.util.* 系统提供的工具包
  * java.net.* 网络包，用于网络开发
  * java.awt.* GUI，界面开发

* 引入包

  * 导入某个类

    ```java
    import java.util.Scanner; // 表示只引入Scanner类
    ```

  * 导入整个包

    ```java
    import java.util.*; // 通过*引入整个util包
  
* package语法用于打包，声明当前类所属的包，需要放在类的最上面，一个类中只能有一个package指令

* import引入需要放在package和类之间，多次引入顺序没有关系


## 跳过：

1. 数组的作业
2. oop初级的作业
3. 继承的作业
## 进度记录：

1. 数组的作业
2. oop初级的作业
3. 继承的作业
